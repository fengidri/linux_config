#!/bin/python2.7
#encoding: utf8


import os
import tempfile
import time
import sys
import hashlib

import tty, termios
import git
import subprocess
import re
import pty
import fcntl
import termcolor

class g:
    addtional = None
    addtional_path = os.path.expanduser('~/.kernel_patch/addtion')
    patch_test   = False
    upstream     = False
    in_relay_to  = None
    msgid_cmd    = None
    msgid_option = None

def input(msg):
    sys.stdout.write(msg)

    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(sys.stdin.fileno())
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)

    print ch

    return ch.lower()

def get_patch_key_path(index):
    parent_hash = os.popen('git log --pretty=format:%H -' + str(index + 1)).readlines()[-1].strip()
    branch = os.popen('git rev-parse --abbrev-ref HEAD').read().strip()
    path = os.path.realpath(os.getcwd())

    m = hashlib.md5()
    m.update(parent_hash)
    m.update(branch)
    m.update(path)
    h = m.hexdigest()
    return os.path.expanduser('~/.kernel_patch/msgid/%s' % h)

def save_msgid(patch, num):
    f = get_patch_key_path(num)
    if os.path.exists(f):
        return

    subject = None
    msgid = None

    for line in open(patch).readlines():
        line = line.split(' ', 1)
        if line[0] == 'Message-Id:':
            msgid = line[1].strip()

        if line[0] == 'Subject:':
            subject = line[1].strip()

    c = '%s\n%s\n%s\n' % (time.time(), subject, msgid)

    open(f, 'w').write(c)



def check_additional(chash):
    path = g.addtional_path
    if not os.path.exists(path):
        return

    body = git.get_commit_body(chash)

    if body.find('\n---') > -1:
        return

    if not g.addtional:
        f = '/tmp/tmp-kernel-patch-%s-%s'  % (time.time(), os.getpid())
        a = open(path).read()
        open(f, 'w').write(a)

        c = input(termcolor.colored('>> check addition.', 'yellow') + ' edit:Y noedit: N skip: S:')
        if c == 'y':
            os.system('vim ' + f )
        elif c == 'n':
            pass
        else:
            return

        g.addtional = open(f).read()

    body = body + '\n\n---\n' + g.addtional

    git.commit_change(chash, body)

def cover_edit(patch):
    path = os.path.expanduser('~/.kernel_patch/addtion')
    if os.path.exists(path):
        c = open(patch).read()
        if c.find('\n---') == -1:
            c = c + '\n---\n' + open(path).read()
            open(patch, 'w').write(c)

    os.system('vim ' + patch)

def step_msg(msg):
    return termcolor.colored(msg, 'yellow')

def get_reply_from_mutt():
    f = '/tmp/message_id_file.%s' % time.time()
    os.environ['message_id_file'] = f


    prompt = "%s will start. run: %s Y/N:" % (g.msgid_cmd, g.msgid_option)
    c = input(prompt)
    if c != 'y':
        return

    os.system(g.msgid_cmd)
    if not os.path.isfile(f):
        return

    lines = open(f).readlines()
    subject = lines[0].strip()
    msgid = lines[1].strip()
    print("Got MSGID From %s" % g.msgid_cmd)
    print(" subject: %s" % subject)
    print(" msgid:   %s" % msgid)
    if msgid:
        return msgid


def check_in_reply_to(num):
    if g.in_relay_to:
        return  " --in-reply-to '%s'" % g.in_relay_to

    f = get_patch_key_path(num)
    if not os.path.exists(f):
        return ''

    msg = " please input last msgid or N or M(use neomutt to select):"
    print(step_msg('>> check message id'))

    while True:
        print(msg)

        msgid = sys.stdin.readline().strip()
        if len(msgid) != 1:
            break

        if msgid.lower() == 'n':
            return ''

        if msgid.lower() == 'm':
            msgid = get_reply_from_mutt()
            if msgid:
                break

    return  " --in-reply-to '%s'" % msgid


def check_patch(patchs):
    print('\n-----------------------------------------------------')

    print(step_msg(">> run ./scripits/checkpatch.pl"))


    for patch in patchs:
        m, s = pty.openpty()
        flag = fcntl.fcntl(m, fcntl.F_GETFD)
        fcntl.fcntl(m, fcntl.F_SETFL, flag | os.O_NONBLOCK)

        ignore = "FILE_PATH_CHANGES,GIT_COMMIT_ID,COMMIT_LOG_LONG_LINE,COMMIT_MESSAGE,CONFIG_DESCRIPTION,MISSING_SIGN_OFF,NO_AUTHOR_SIGN_OFF,BAD_SIGN_OFF"

        p = subprocess.Popen(['./scripts/checkpatch.pl', '-q', '--show-types', '--ignore', ignore, patch], stdout=s, stderr=s)



        s = ''
        e = False
        while True:
            try:
                buf = os.read(m, 1024)
            except OSError:
                buf = None

            if buf:
                s = s + buf
            else:
                if e:
                    break

                if p.poll() is not None:
                    e = True

        if p.returncode:
            print('')
            for line in s.split('\n'):
                print '| ', line

            print '^ %s %s\n' % (patch, termcolor.colored('fail', 'red'))
        else:
            print '^ %s %s' % (patch, termcolor.colored('success', 'green'))

def format_patch(prefix, num):
    reply = check_in_reply_to(num)

    print(step_msg(">> format-patch."))
    cmd="git format-patch  -{num} --subject-prefix '{prefix}' {option}{reply}"

    if num > 1:
        m = '--thread=shallow -n --cover-letter '
    else:
        m = ''

    cmd = cmd.format(num = num, prefix = prefix, option = m, reply = reply)

    print("\n$ %s" % cmd)

    patchs = os.popen(cmd).readlines()
    patchs = [x.strip() for x in patchs]

    for p in patchs:
        print '    ' + p

    return patchs

def read_cover(path):
    lines = open(path).readlines()

    body = []
    subject = None

    mode_subject     = 1
    mode_skip_head   = 2
    mode_blurb_white = 3
    mode_blurb_body  = 4
    mode = mode_subject

    for line in lines:
        line = line.strip()
        if mode_subject == mode:
            if line.startswith('Subject: '):
                index = line.find(']')
                subject = line[index + 1:].strip()
                mode = mode_skip_head
            continue

        if mode_skip_head == mode:
            if not line:
                mode = mode_blurb_white
                continue

            if re.match('^[a-zA-Z-]+: ', line):
                continue

            body.append(line)
            mode = mode_blurb_body
            continue

        if mode_blurb_white == mode:
            if not line:
                continue

            body.append(line)
            mode = mode_blurb_body
            continue

        if mode_blurb_body == mode:
            if re.search(' \(\d+\):$', line):
                break

            body.append(line)

    return subject, '\n'.join(body)

def fill_cover(path, subject=None, blurb=None):
    lines = open(path).readlines()
    o = []

    need_check_addtion = True
    if not os.path.exists(g.addtional_path):
        need_check_addtion = False

    for line in lines:
        if line.startswith('Subject: ') and subject:
            line = line.replace('*** SUBJECT HERE ***', subject)
            o.append(line)
            continue

        if line == '*** BLURB HERE ***\n':
            if blurb:
                o.append(blurb)
            else:
                o.append(line)

            if os.path.exists(g.addtional_path):
                if blurb and blurb.find('\n---\n') > -1:
                    need_check_addtion = False
                else:
                    o.append('\n\n---\n')
                    o.append(open(g.addtional_path).read())
                    need_check_addtion = True
            continue

        o.append(line)

    open(path, 'w').write(''.join(o))
    return need_check_addtion


def make_patchs(prefix, num):
    chashs = git.get_commit_hash(num)

    if not g.patch_test:
        cover_path = '0000-cover-letter.patch'
        cover_subject = None

        if os.path.exists(cover_path):
            cover_subject, cover_body = read_cover(cover_path)


        patchs = format_patch(prefix, num)

        print('\n------------------------cover-----------------------------')

        need = None

        if cover_subject:
            print('Subject: ' + cover_subject)
            print('---')
            print(cover_body)
            print('=================')

            char = input('Use last cover msg y/n:')
            if char == 'y':
                need = fill_cover(cover_path, cover_subject, cover_body)

        if None == need:
            need = fill_cover(cover_path)

        if need:
            input('need to edit cover for addition. anykey:')
            os.system('vim ' + cover_path)
    else:
        patchs = format_patch(prefix, num)

    return patchs

def make_patch(prefix):
    chash = git.get_commit_hash(1)[0]
    if not g.upstream:
        check_additional(chash)

    return format_patch(prefix, 1)


def send_email(patchs, num, email_list_name):
    print('\n-----------------------------------------------------')
    for p in patchs:
        print p


    cmd = "git send-email {patch} --no-thread --suppress-cc=all --quiet"

    print cmd

    path = os.path.expanduser('~/.kernel_patch/email/' + email_list_name)
    if os.path.exists(path):
        lines = open(path).readlines()
        for e in lines:
            e = e.strip()
            if not e:
                continue

            if e[0] == '#':
                continue

            print ('    ' + e)
            cmd = cmd + ' ' + e

    char = input('Send Email With this cmd: y/n:')
    if char != 'y':
        return


    for patch in patchs:
        os.system(cmd.format(patch = patch))



def _make_patch(args):
    prefix = args.prefix
    num = args.num
    if num.isdigit():
        num = int(num)
    else:
        lines = os.popen('git log --oneline %s~..HEAD' % num).readlines()
        num = len(lines)
        print("The first commit: %s" % lines[-1].strip())

    g.in_relay_to = args.relay
    if args.R:
        g.in_relay_to = 'mail'

    if g.in_relay_to:
        if g.in_relay_to[0] == '@':
            g.in_relay_to = open(g.in_relay_to[1:]).read().strip()
            if g.in_relay_to:
                print("got message-id: %s" % g.in_relay_to)
            else:
                return

        if g.in_relay_to == 'mail':
            g.in_relay_to = get_reply_from_mutt()
            if not g.in_relay_to:
                return


    if args.t:
        g.patch_test = True

    if args.u:
        g.upstream = True

    if prefix.find("PATCH") == -1:
        print("prefix must include PATCH")
        return

    if 1 == num:
        ps = make_patch(prefix)
    else:
        ps = make_patchs(prefix, num)


    if not args.skip_checkpatch:
        check_patch(ps)

    if args.s:
        print("\n")
        print(step_msg(">> send email."))
        cmd = "email_post -g -t %s  %s" % (args.s, ' '.join(ps))
        os.system(cmd)
        save_msgid(ps[0], num)





import argparse
parser = argparse.ArgumentParser(description="kernel patch")

mk = parser
mk.add_argument('prefix', help="patch prefix")
mk.add_argument('num', help="commit num or first commit")
mk.add_argument('--save-cover', help="use the last 000-0-cover-letter.patch",
        default=False, type=bool)
mk.add_argument('-t', help="for test, skip edit cover", action="store_true")
mk.add_argument('-s', help="send email, special the email list file under ~/.kernel_patch/email/")
mk.add_argument('-u', help="upstream patch no alibaba patch", action="store_true")
mk.add_argument('-r', '--relay', help="""--in-reply-to msgid.
@ prefix means that is filename of message-id.
mail means will open mail client to get message-id.
""")
mk.add_argument('-R', type=bool)
mk.add_argument('--skip-checkpatch', help="skip checkpatch", action="store_true")
mk.set_defaults(func=_make_patch)



args = parser.parse_args()

args.func(args)



