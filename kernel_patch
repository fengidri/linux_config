#!/bin/python2.7
#encoding: utf8


import os
import tempfile
import time
import sys
import hashlib

import tty, termios
import git
import subprocess
import re
import pty
import fcntl
import termcolor

class g:
    addtional = None
    addtional_path = os.path.expanduser('~/.kernel_patch/addtion')
    patch_test = False

def save_msgid(patch, num):
    f = get_patch_key_path(num)
    if os.path.exists(f):
        return

    for line in open(patch).readlines():
        line = line.split()
        if line[0] == 'Message-Id:':
            msgid = line[1]
            break

    open(f, 'w').write(msgid)

def input(msg):
    sys.stdout.write(msg)

    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(sys.stdin.fileno())
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)

    print ch

    return ch.lower()

def get_patch_key_path(index):
    parent_hash = os.popen('git log --pretty=format:%H -' + str(index + 1)).readlines()[-1].strip()
    branch = os.popen('git rev-parse --abbrev-ref HEAD').read().strip()
    path = os.path.realpath(os.getcwd())

    m = hashlib.md5()
    m.update(parent_hash)
    m.update(branch)
    m.update(path)
    h = m.hexdigest()
    return os.path.expanduser('~/.kernel_patch/%s' % h)



def check_additional(chash):
    path = g.addtional_path
    if not os.path.exists(path):
        return

    body = git.get_commit_body(chash)

    if body.find('\n---') > -1:
        return

    if not g.addtional:
        f = '/tmp/tmp-kernel-patch-%s-%s'  % (time.time(), os.getpid())
        a = open(path).read()
        open(f, 'w').write(a)

        input('need to edit addition. anykey:')
        os.system('vim ' + f )
        g.addtional = open(f).read()

    body = body + '\n\n---\n' + g.addtional

    git.commit_change(chash, body)

def cover_edit(patch):
    path = os.path.expanduser('~/.kernel_patch/addtion')
    if os.path.exists(path):
        c = open(patch).read()
        if c.find('\n---') == -1:
            c = c + '\n---\n' + open(path).read()
            open(patch, 'w').write(c)

    os.system('vim ' + patch)


def check_in_reply_to(num):
    f = get_patch_key_path(num)
    if os.path.exists(f):
        char = input('Found last msgid, use it as the --in-reply-to Y/N: ')
        if char == 'y':
            return  " --in-reply-to '%s'" % open(f).read().strip()

    return ''

def check_patch(patchs):
    print('\n-----------------------------------------------------')
    print("run ./scripits/checkpatch.pl")


    for patch in patchs:
        m, s = pty.openpty()
        flag = fcntl.fcntl(m, fcntl.F_GETFD)
        fcntl.fcntl(m, fcntl.F_SETFL, flag | os.O_NONBLOCK)

        p = subprocess.Popen(['./scripts/checkpatch.pl', patch], stdout=s,
                stderr=s)

        s = ''
        e = False
        while True:
            try:
                buf = os.read(m, 1024)
            except OSError:
                buf = None

            if buf:
                s = s + buf
            else:
                if e:
                    break

                if p.poll() is not None:
                    e = True

        if p.returncode:
            print('')
            for line in s.split('\n'):
                print '| ', line

            print '^ %s %s\n' % (patch, termcolor.colored('fail', 'red'))
        else:
            print '^ %s %s' % (patch, termcolor.colored('success', 'green'))

def format_patch(prefix, num):
    reply = check_in_reply_to(num)
    cmd="git format-patch  -{num} --subject-prefix '{prefix}' {option}{reply}"

    if num > 1:
        m = '--thread=shallow -n --cover-letter '
    else:
        m = ''

    cmd = cmd.format(num = num, prefix = prefix, option = m, reply = reply)

    print("make patch by cmd:\n$ %s" % cmd)

    patchs = os.popen(cmd).readlines()
    patchs = [x.strip() for x in patchs]

    for p in patchs:
        print '    ' + p

    return patchs

def read_cover(path):
    lines = open(path).readlines()

    body = []
    subject = None

    mode_subject     = 1
    mode_skip_head   = 2
    mode_blurb_white = 3
    mode_blurb_body  = 4
    mode = mode_subject

    for line in lines:
        line = line.strip()
        if mode_subject == mode:
            if line.startswith('Subject: '):
                index = line.find(']')
                subject = line[index + 1:].strip()
                mode = mode_skip_head
            continue

        if mode_skip_head == mode:
            if not line:
                mode = mode_blurb_white
                continue

            if re.match('^[a-zA-Z-]+: ', line):
                continue

            body.append(line)
            mode = mode_blurb_body
            continue

        if mode_blurb_white == mode:
            if not line:
                continue

            body.append(line)
            mode = mode_blurb_body
            continue

        if mode_blurb_body == mode:
            if re.search(' \(\d+\):$', line):
                break

            body.append(line)

    return subject, '\n'.join(body)

def fill_cover(path, subject=None, blurb=None):
    lines = open(path).readlines()
    o = []

    need_check_addtion = True
    if not os.path.exists(g.addtional_path):
        need_check_addtion = False

    for line in lines:
        if line.startswith('Subject: ') and subject:
            line = line.replace('*** SUBJECT HERE ***', subject)
            o.append(line)
            continue

        if line == '*** BLURB HERE ***\n':
            if blurb:
                o.append(blurb)
            else:
                o.append(line)

            if os.path.exists(g.addtional_path):
                if blurb and blurb.find('\n---\n') > -1:
                    need_check_addtion = False
                else:
                    o.append('\n\n---\n')
                    o.append(open(g.addtional_path).read())
                    need_check_addtion = True
            continue

        o.append(line)

    open(path, 'w').write(''.join(o))
    return need_check_addtion


def make_patchs(prefix, num):
    chashs = git.get_commit_hash(num)

    if not g.patch_test:
        cover_path = '0000-cover-letter.patch'
        cover_subject = None

        if os.path.exists(cover_path):
            cover_subject, cover_body = read_cover(cover_path)


        patchs = format_patch(prefix, num)

        print('\n------------------------cover-----------------------------')

        need = None

        if cover_subject:
            print('Subject: ' + cover_subject)
            print('---')
            print(cover_body)
            print('=================')

            char = input('Use last cover msg y/n:')
            if char == 'y':
                need = fill_cover(cover_path, cover_subject, cover_body)

        if None == need:
            need = fill_cover(cover_path)

        if need:
            input('need to edit cover for addition. anykey:')
            os.system('vim ' + cover_path)
    else:
        patchs = format_patch(prefix, num)

    check_patch(patchs)
    return patchs

def make_patch(prefix):
    chash = git.get_commit_hash(1)[0]
    check_additional(chash)

    patchs = format_patch(prefix, 1)

    check_patch(patchs)
    return patchs




def send_email(patchs):
    print('\n-----------------------------------------------------')
    for p in patchs:
        print p


    cmd = "git send-email {patch} --no-thread --suppress-cc=all --quiet"

    print cmd

    path = os.path.expanduser('~/.kernel_patch/email')
    if os.path.exists(path):
        lines = open(path).readlines()
        for e in lines:
            e = e.strip()
            print ('    ' + e)
            cmd = cmd + ' ' + e

    char = input('Send Email With this cmd: y/n:')
    if char != 'y':
        return

    save_msgid(patchs[0], num)

    for patch in patchs:
        os.system(cmd.format(patch = patch))


def merge(args):
    send_email(match_patch(args.prefix, args.num))

def _make_patch(args):
    prefix = args.prefix
    num = args.num

    if args.t:
        g.patch_test = True

    if prefix.find("PATCH") == -1:
        print("prefix must include PATCH")
        return

    if 1 == num:
        make_patch(prefix)
    else:
        make_patchs(prefix, num)

def _send(args):
    print args.patchs
    return
    send_email(args.patchs)




import argparse
parser = argparse.ArgumentParser(description="kernel patch")
subparsers = parser.add_subparsers(title='sub command')

mk = subparsers.add_parser('patch')
mk.add_argument('prefix', help="patch prefix")
mk.add_argument('num', help="how many commit used", default=1, type=int)
mk.add_argument('--save-cover', help="use the last 000-0-cover-letter.patch",
        default=False, type=bool)
mk.add_argument('-t', help="for test, skip edit cover", action="store_true")
mk.set_defaults(func=_make_patch)

send = subparsers.add_parser('send')
send.add_argument('patchs', help="patch to send", nargs='+')
send.set_defaults(func=_send)

merge = subparsers.add_parser('merge')
merge.set_defaults(func=merge)

args = parser.parse_args()

args.func(args)



